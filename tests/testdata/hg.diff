diff -r cfa90e9fc593 src/jquery.luminousify/jquery.luminousify.js
--- a/src/jquery.luminousify/jquery.luminousify.js	Wed Feb 23 19:14:47 2011 +0000
+++ b/src/jquery.luminousify/jquery.luminousify.js	Thu Mar 17 14:23:18 2011 +0000
@@ -1,3 +1,8 @@
+/**
+ * Syntax highlighting via AJAX.
+ * See asgaard.co.uk/misc/jquery/?show=luminousify for details
+ */
+
 (function($){
   var __included = false;
   
@@ -5,8 +10,7 @@
     var $t = this,
         i = 0;
     
-    options = $.extend(
-      {
+    options = $.extend({
         style: 'luminous_light.css',
         language: false,
         defaultLanguage: false,
@@ -17,7 +21,7 @@
         line_numbers: false,
         group: 10 // number of code snippets to group into one request.
                  // This reduces the HTTP overhead but also ties up the server 
-                 // for longer at once. 5-10 is resaonable.
+                 // for longer at once. 5-10 is reasonable.
                  // server side maximum is 20.
       }, options);
     
@@ -58,7 +62,6 @@
         var t = $($t.get(i+j));
         var code = t.html();
 
-
         var language = options.language;
         if (!language)
           language = t.attr('lang');
@@ -69,26 +72,29 @@
         reqs.push( { code: code, language: language, line_numbers: options.line_numbers,
                    inline: options.inline, escaped: true} );
       }
-      
-      
-      
-      
-      
-      $.post(options.url,
-             {
-               requests: reqs
-             },
-        
-        function(data) {
+      $.post(options.url, { requests: reqs },function(data) {
           // the return is JSON encoded, but we know it's just an array of 
           // strings. To avoid depending on a JSON parser we're going to 
           // regex extract them
           var strings = data.match(/"([^\\"]+|\\"|\\.)*"/g);
           for (var a = 0; a<strings.length; a++) {
-            // we KNOW anything in here is not executable code because it's 
-            // wrapped in quotes. It may contain escape sequences. The easiest
-            // way to decode these therefore is to eval() it. This is safe.       
-            var s = eval(strings[a]); 
+            // now we need to unescape some bits. I think this is right.
+            var s = strings[a].slice(1, -1).replace(/\\(u[a-fA-F0-9]{4}|.)/g, function($0, $1){ 
+              // unicode
+              if ($1.charAt(0) === 'u')
+                return String.fromCharCode(parseInt($1.slice(1), 16));
+              
+              switch($1) {
+                // things that translate into real escape sequences
+                case 'b': return '\b';
+                case 'f': return '\f';                
+                case 'n': return '\n';
+                case 'r': return '\r';
+                case 't': return '\t';
+                // other stuff which we can drop the slash from, like \"
+                default: return $1;
+              }              
+            });
             var $r = $(s);
             if (!options.inline)
               $r.addClass('luminousified');
diff -r cfa90e9fc593 src/json/json.js
--- a/src/json/json.js	Wed Feb 23 19:14:47 2011 +0000
+++ b/src/json/json.js	Thu Mar 17 14:23:18 2011 +0000
@@ -158,21 +158,53 @@
     while ((c = get()) !== false) {
       if (c === '\\') {
         var lookahead = get();
+        var append = '';
         switch(lookahead) {
-          case quote:
-          case '\\':
-          case '/':
+          
+          // strip the slash from these
+          case quote:  //fallthrough
+          case '\\':   // ....
+          case '/':    
+            append = lookahead;
+            break;
+          // these are real escape sequences which we need to encode
+          // into the string
           case 'b':
+            append = '\b';
+            break;
           case 'f':
+            append = '\f';
+            break;
           case 'n':
+            append = '\n';
+            break;
           case 'r':
+            append = '\r';
+            break;
           case 't':
+            append = '\t';
+            break;
           case 'u':
+            // unicode. To build this here we need to look at the next four 
+            // chars. Interestingly just leaving '\u' and concatenating the
+            // sequence seems to pass Chrome and Firefox but IE doesn't like it.
+            var hex = peek(4);
+            var hex_ = '';
+            for (var i=0; i<hex.length; i++) {
+              if (!(/[a-fA-F0-9]/.test(hex.charAt(i)))) {
+                error('Expected hex digit, found: "' + hex.charAt(i) + '"', 0);
+                break;
+              }
+              hex_ += get();
+            }
+            append = String.fromCharCode( parseInt(hex_, 16) );            
             break;
           default:
             error('Unrecognised escape sequence: \\' + lookahead, 0);
+            append = c + lookahead;
+            break;
         }
-        ret += c + lookahead;
+        ret += append;
       }
       else if (c === quote) {
         stack.pop();
@@ -440,34 +472,29 @@
 
 /**
  * @param {*} object
+ * @param {boolean=} strict
  * @return {string}
  * 
  * FIXME: this will infinite recurse on circular references.
+ * 
+ * If strict is set to true and any of: undefined, NaN, [+-]?Infinfity occurs 
+ *  anywhere in the input, an exception will be thrown;
  */
-function writeJson(object) {  
+function writeJson(object, strict) {  
   var i, vals;
+  strict = !!strict;
   
-  if (typeof object === 'undefined')
+  if (typeof object === 'undefined') {
+    if (strict) {
+      throw 'undefined object was given to JSON encoder';
+    }
     return 'undefined';
+  }
   else if (object === null)
     return 'null';
-  else if (typeof object === 'string'){
-    // This might be wrong.
-    return '"' + object.replace(/(\\)*(["'])/g, function($0, $1, $2) {
-      $1 = $1 || '';
-      var escaped = ($1.length % 2);
-      if (escaped) {
-        if ($2 === "'") {
-          return $1.slice(1) + $2;
-        }
-        else return $0;
-      }
-      else {
-        if ($2 === '"')
-          return '\\' + $0;
-        else return $0;
-      }
-    }) + '"';
+  else if (typeof object === 'string') {
+    return '"' + object.replace(/[\"\\/\b\f\n\r\t]/g, 
+                                function($0) { return '\\' + $0; })  + '"';
   }
   else if (object.constructor.toString().indexOf('Array') !== -1) {
     vals = [];
@@ -483,6 +510,16 @@
     }
     return '{' + vals.join(',') + '}';
   }
+  
+  else if (typeof object === 'number') {
+    if (strict && isNaN(object)) {
+      throw 'NaN was given to JSON encoder';
+    }
+    else if (strict && !isFinite(object)) {
+      throw '+/- Infinity was given to JSON encoder';
+    }
+    return object.toString();
+  }  
   else if (object.toString) 
     return object.toString();
   else // meh
diff -r cfa90e9fc593 src/json/json.js.extern
--- a/src/json/json.js.extern	Wed Feb 23 19:14:47 2011 +0000
+++ b/src/json/json.js.extern	Thu Mar 17 14:23:18 2011 +0000
@@ -7,6 +7,7 @@
 
 /**
  * @param {*} object
+ * @param {boolean=} strict
  * @return {string}
  */
-function writeJson(object) {}
\ No newline at end of file
+function writeJson(object, strict) {}
